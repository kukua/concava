{
    "docs": [
        {
            "location": "/",
            "text": "ConCaVa\n\n\nConfiguration driven binary payload processor for Converting, Calibrating, and Validating dynamic sensor data.\n\n\n\nThis description is a mouthful, so let's break it down:\n\n\n\n\nConfiguration driven:\n instead of writing custom software to handle sensor data, ConCaVa allows you to configure how the data of each device should be processed.\n\n\nBinary payload processor:\n Sensing sensor data in binary is efficient and cheap, but requires a conversion step (how to make sense of all the ones and zeros).\n\n\nConverting data:\n Converting bits into numbers.\n\n\nCalibrating data:\n Custom functionality to alter the data.\n\n\nValidating data:\n Making sure the data is correct, e.g. lies within the range in which the sensor can measure.\n\n\nDynamic sensor data:\n Allowing different sensors to send their data to a single endpoint, no matter what the data format is.\n\n\n\n\nChallenges\n\n\nEfficiently processing sensor data of a big variety of devices is hard. But there is plenty of room of doing it in a generic way. That's where ConCaVa comes into play. These are the common challenges:\n\n\n\n\nLimited bandwidth.\n When sensors are sending over 3G or LoRa, bandwidth is limited. In these situations the amount of data must be brought to a minimum. Using formats like XML or JSON includes the data format, which costs extra bytes. Binary is the most efficient way of sending sensor data, however introduces other challenges like data conversion.\n\n\nConverting data.\n Sensors provide different types of data and often via different protocols (LoRa, MQTT, SigFox, etc.). This data needs to be converted. Usually done by software that is specifically developed for that use case.\n\n\nCalibrating data.\n Measurements require different types of calibration. E.g. sending a temperature as 16bit integer and dividing it by 100 to get a two decimal precision.\n\n\nValidating data.\n Each type of sensor is validated differently. E.g. checking if the measurement of a temperature sensor lies between its maximum bounds of -40\u00b0C and +85\u00b0C. If below or above, correct or discard the data. Each of these rules are implemented seperately.\n\n\nScalability.\n Adding new devices with different protocols requires changing the software that handles the incoming data.\n\n\n\n\nThe first point is solved by using binary data, points 2, 3, and 4 are solved by ConCaVa, and point 5 is solved by using a configuration driven approach.\n\n\nDataflow\n\n\nBefore going into detail, it is important to know how the data flows through a system that's using ConCaVa:\n\n\n\n\nSensors send their binary payload to the ConCaVa \nHTTP API endpoint\n. If a sensor communicates via a different protocol (LoRa, SPUL, MQTT, etc.) a \nconnector\n can be used to forward the data to ConCaVa, so the convert, calibrate, and validate steps can still be utilized. The image above shows usage of the \nSPUL protocol and connector\n.\n\n\nIn the next chapters the installation and configuration will be handled.\n\n\n\n\nFor contributing, providing feedback, or support please go to the \nGithub repository\n.\n\nSee the \nintroduction slides\n for a quick overview of ConCaVa.",
            "title": "Introduction"
        },
        {
            "location": "/#concava",
            "text": "Configuration driven binary payload processor for Converting, Calibrating, and Validating dynamic sensor data.  This description is a mouthful, so let's break it down:   Configuration driven:  instead of writing custom software to handle sensor data, ConCaVa allows you to configure how the data of each device should be processed.  Binary payload processor:  Sensing sensor data in binary is efficient and cheap, but requires a conversion step (how to make sense of all the ones and zeros).  Converting data:  Converting bits into numbers.  Calibrating data:  Custom functionality to alter the data.  Validating data:  Making sure the data is correct, e.g. lies within the range in which the sensor can measure.  Dynamic sensor data:  Allowing different sensors to send their data to a single endpoint, no matter what the data format is.",
            "title": "ConCaVa"
        },
        {
            "location": "/#challenges",
            "text": "Efficiently processing sensor data of a big variety of devices is hard. But there is plenty of room of doing it in a generic way. That's where ConCaVa comes into play. These are the common challenges:   Limited bandwidth.  When sensors are sending over 3G or LoRa, bandwidth is limited. In these situations the amount of data must be brought to a minimum. Using formats like XML or JSON includes the data format, which costs extra bytes. Binary is the most efficient way of sending sensor data, however introduces other challenges like data conversion.  Converting data.  Sensors provide different types of data and often via different protocols (LoRa, MQTT, SigFox, etc.). This data needs to be converted. Usually done by software that is specifically developed for that use case.  Calibrating data.  Measurements require different types of calibration. E.g. sending a temperature as 16bit integer and dividing it by 100 to get a two decimal precision.  Validating data.  Each type of sensor is validated differently. E.g. checking if the measurement of a temperature sensor lies between its maximum bounds of -40\u00b0C and +85\u00b0C. If below or above, correct or discard the data. Each of these rules are implemented seperately.  Scalability.  Adding new devices with different protocols requires changing the software that handles the incoming data.   The first point is solved by using binary data, points 2, 3, and 4 are solved by ConCaVa, and point 5 is solved by using a configuration driven approach.",
            "title": "Challenges"
        },
        {
            "location": "/#dataflow",
            "text": "Before going into detail, it is important to know how the data flows through a system that's using ConCaVa:   Sensors send their binary payload to the ConCaVa  HTTP API endpoint . If a sensor communicates via a different protocol (LoRa, SPUL, MQTT, etc.) a  connector  can be used to forward the data to ConCaVa, so the convert, calibrate, and validate steps can still be utilized. The image above shows usage of the  SPUL protocol and connector .  In the next chapters the installation and configuration will be handled.   For contributing, providing feedback, or support please go to the  Github repository . \nSee the  introduction slides  for a quick overview of ConCaVa.",
            "title": "Dataflow"
        },
        {
            "location": "/installation/",
            "text": "Installation\n\n\nConCaVa can be run as a NodeJS program or in a Docker container.\n\n\nNodeJS\n\n\ngit clone https://github.com/kukua/concava\ncd concava\ncp config.js.example config.js\nchmod 600 config.js\n# \n Edit config.js\n\nnpm install\nnpm start\n# Should show \nListening on port 3000\n in log file\n\n\n\n\nTested with NodeJS v5.0 and NPM v3.3.\n\n\nDocker\n\n\nFirst, \ninstall Docker\n. Then run:\n\n\ncurl https://raw.githubusercontent.com/kukua/concava/master/config.js.example \n config.js\nchmod 600 config.js\n# \n Edit config.js\n\ntouch /tmp/output.log\n\ndocker run -d -p 3000:3000 -v $PWD/config.js:/data/config.js \\\n    -v /tmp/output.log:/tmp/output.log --name concava kukuadev/concava\n# Should show \nListening on port 3000\n in log file\n\n\n\n\nTested with Docker v1.9.",
            "title": "Installation"
        },
        {
            "location": "/installation/#installation",
            "text": "ConCaVa can be run as a NodeJS program or in a Docker container.",
            "title": "Installation"
        },
        {
            "location": "/installation/#nodejs",
            "text": "git clone https://github.com/kukua/concava\ncd concava\ncp config.js.example config.js\nchmod 600 config.js\n#   Edit config.js\n\nnpm install\nnpm start\n# Should show  Listening on port 3000  in log file  Tested with NodeJS v5.0 and NPM v3.3.",
            "title": "NodeJS"
        },
        {
            "location": "/installation/#docker",
            "text": "First,  install Docker . Then run:  curl https://raw.githubusercontent.com/kukua/concava/master/config.js.example   config.js\nchmod 600 config.js\n#   Edit config.js\n\ntouch /tmp/output.log\n\ndocker run -d -p 3000:3000 -v $PWD/config.js:/data/config.js \\\n    -v /tmp/output.log:/tmp/output.log --name concava kukuadev/concava\n# Should show  Listening on port 3000  in log file  Tested with Docker v1.9.",
            "title": "Docker"
        },
        {
            "location": "/configuration/",
            "text": "Configuration\n\n\nThe ConCaVa repository contains a \nconfig.js.example file\n, containing all the configuration options.\n\n\nAdapters\n\n\nConCaVa allows you to provide your own authentication, metadata (device configuration), and storage. These are down through generic adapters.\nAdapters are simply asynchronous JavaScript functions. Each of these adapter functions accepts four or five arguments:\n\n\n// req = Express request\n// config = auth, metadata, or storage object from config.js\n// data = SensorData instance\n// classes = { SensorData, SensorAttribute }\n// cb = callback function\n\nfunction (req, config, data, cb) {}\nfunction (req, config, data, classes, cb) {}\n\n\n\n\nThe latter is used for providing metadata with the classes used by ConCaVa.\n\n\nAuthentication\n\n\nExample authentication adapter:\n\n\nfunction auth (req, config, data, cb) {\n    // return cb() // To disable authentication\n\n    console.log(req.auth) // { udid: '...', token: '...' }\n    // token will only be added if config.byToken === true\n\n    var user = { id: 1, name: 'User 1' }\n    cb(null, user)\n    // The value of user is assigned to req.user\n}\n\n\n\n\nMetadata\n\n\nExample metadata adapter:\n\n\nfunction metadata (req, config, data, classes, cb) {\n    // data is instance of classes.SensorData\n    if (data.getDeviceId() !== '0000000000000001') {\n        return cb('No metadata for device.')\n    }\n\n    var attr1 = new classes.SensorAttribute('attr1')\n    attr1.addConverter('uint32be')\n    attr1.addValidator('min', 100)\n    attr1.addValidator('max', 1300)\n\n    var attr2 = new classes.SensorAttribute('attr2')\n    attr2.addConverter('int16le')\n    attr2.addCalibrator('return value + 7')\n\n    data.setAttributes([attr1, attr2])\n    cb()\n}\n\n\n\n\nStorage\n\n\nExample storage adapter:\n\n\nfunction storage (req, config, data, cb) {\n    var udid = data.getDeviceId()\n\n    console.log(udid, data.getData())\n    cb()\n}\n\n\n\n\n\n    \nNote\n\n    \nIn debug mode, ConCaVa will also write the data to the log file.\n\n\n\n\n\nAvailable\n\n\nThe following adapters are available:\n\n\n\n\nMySQL authentication, metadata, and storage\n\n\nOrion Context Broker authentication, metadata, and storage\n\n\nMQTT storage\n\n\nInfluxDB storage\n\n\n\n\nSearch for 'adapter' on Github\n to see all official adapters.\nContributing other adapters is highly appreciated. See \nthe contributing page\n for more information.\n\n\nConnectors\n\n\nConnectors are used to support other communication protocols. They act as a proxy for ConCaVa. A connector extracts the UDID and binary payload from protocol packet of your liking. For example: the MQTT connector provides an MQTT broker that uses the \nclientId\n and \npassword\n configuration options for UDID and auth token. Any data it receives will used as binary payload to forward to ConCaVa.\n\n\nAvailable\n\n\nThe following connectors are available:\n\n\n\n\nLoRa\n. Handles LoRa XML (from a KPN server webhook for example).\n\n\nLoRa TTN\n. Handles The Things Network LoRa packets.\n\n\nMQTT\n.\n\n\nSPUL\n stands for \nSensor Protocol Ultra Light\n. Documentation can be \nfound here\n.\n\n\n\n\nSearch for 'ConCaVa' on the Docker Hub\n to see all connectors.\nContributing other connectors is highly appreciated. See \nthe contributing page\n for more information.",
            "title": "Configuration"
        },
        {
            "location": "/configuration/#configuration",
            "text": "The ConCaVa repository contains a  config.js.example file , containing all the configuration options.",
            "title": "Configuration"
        },
        {
            "location": "/configuration/#adapters",
            "text": "ConCaVa allows you to provide your own authentication, metadata (device configuration), and storage. These are down through generic adapters.\nAdapters are simply asynchronous JavaScript functions. Each of these adapter functions accepts four or five arguments:  // req = Express request\n// config = auth, metadata, or storage object from config.js\n// data = SensorData instance\n// classes = { SensorData, SensorAttribute }\n// cb = callback function\n\nfunction (req, config, data, cb) {}\nfunction (req, config, data, classes, cb) {}  The latter is used for providing metadata with the classes used by ConCaVa.  Authentication  Example authentication adapter:  function auth (req, config, data, cb) {\n    // return cb() // To disable authentication\n\n    console.log(req.auth) // { udid: '...', token: '...' }\n    // token will only be added if config.byToken === true\n\n    var user = { id: 1, name: 'User 1' }\n    cb(null, user)\n    // The value of user is assigned to req.user\n}  Metadata  Example metadata adapter:  function metadata (req, config, data, classes, cb) {\n    // data is instance of classes.SensorData\n    if (data.getDeviceId() !== '0000000000000001') {\n        return cb('No metadata for device.')\n    }\n\n    var attr1 = new classes.SensorAttribute('attr1')\n    attr1.addConverter('uint32be')\n    attr1.addValidator('min', 100)\n    attr1.addValidator('max', 1300)\n\n    var attr2 = new classes.SensorAttribute('attr2')\n    attr2.addConverter('int16le')\n    attr2.addCalibrator('return value + 7')\n\n    data.setAttributes([attr1, attr2])\n    cb()\n}  Storage  Example storage adapter:  function storage (req, config, data, cb) {\n    var udid = data.getDeviceId()\n\n    console.log(udid, data.getData())\n    cb()\n}  \n     Note \n     In debug mode, ConCaVa will also write the data to the log file.   Available  The following adapters are available:   MySQL authentication, metadata, and storage  Orion Context Broker authentication, metadata, and storage  MQTT storage  InfluxDB storage   Search for 'adapter' on Github  to see all official adapters.\nContributing other adapters is highly appreciated. See  the contributing page  for more information.",
            "title": "Adapters"
        },
        {
            "location": "/configuration/#connectors",
            "text": "Connectors are used to support other communication protocols. They act as a proxy for ConCaVa. A connector extracts the UDID and binary payload from protocol packet of your liking. For example: the MQTT connector provides an MQTT broker that uses the  clientId  and  password  configuration options for UDID and auth token. Any data it receives will used as binary payload to forward to ConCaVa.  Available  The following connectors are available:   LoRa . Handles LoRa XML (from a KPN server webhook for example).  LoRa TTN . Handles The Things Network LoRa packets.  MQTT .  SPUL  stands for  Sensor Protocol Ultra Light . Documentation can be  found here .   Search for 'ConCaVa' on the Docker Hub  to see all connectors.\nContributing other connectors is highly appreciated. See  the contributing page  for more information.",
            "title": "Connectors"
        },
        {
            "location": "/api/",
            "text": "HTTP API endpoint\n\n\nConCaVa accepts the following HTTP requests:\n\n\n\n\nPOST /v1/sensorData\n\n\nPUT /v1/sensorData/\ndeviceID\n (where \ndeviceID\n is a lowercase 16 character hex string)\n\n\n\n\nThe requests are identical, except for the device ID which using a \nPOST\n request is prepended to the binary payload.\n\n\nThe following headers are required:\n\n\n\n\nContent-Type: application/octet-stream\n\n\nAuthorization: \nauth\n (e.g. \nToken abcdef0123456789abcdef0123456789\n)\n\n\n\n\nYou can use one of these commands for testing:\n\n\necho '\ndeviceID\nhex\n' | xxd -r -p | \\\n    curl -i -XPOST 'http://localhost:3000/v1/sensorData' \\\n    -H 'Authorization: Token \ntoken\n' \\\n    -H 'Content-Type: application/octet-stream' --data-binary @-\n\necho '\nhex\n' | xxd -r -p | \\\n    curl -i -XPUT 'http://localhost:3000/v1/sensorData/\ndeviceID\n' \\\n    -H 'Authorization: Token \ntoken\n' \\\n    -H 'Content-Type: application/octet-stream' --data-binary @-",
            "title": "API"
        },
        {
            "location": "/api/#http-api-endpoint",
            "text": "ConCaVa accepts the following HTTP requests:   POST /v1/sensorData  PUT /v1/sensorData/ deviceID  (where  deviceID  is a lowercase 16 character hex string)   The requests are identical, except for the device ID which using a  POST  request is prepended to the binary payload.  The following headers are required:   Content-Type: application/octet-stream  Authorization:  auth  (e.g.  Token abcdef0123456789abcdef0123456789 )   You can use one of these commands for testing:  echo ' deviceID hex ' | xxd -r -p | \\\n    curl -i -XPOST 'http://localhost:3000/v1/sensorData' \\\n    -H 'Authorization: Token  token ' \\\n    -H 'Content-Type: application/octet-stream' --data-binary @-\n\necho ' hex ' | xxd -r -p | \\\n    curl -i -XPUT 'http://localhost:3000/v1/sensorData/ deviceID ' \\\n    -H 'Authorization: Token  token ' \\\n    -H 'Content-Type: application/octet-stream' --data-binary @-",
            "title": "HTTP API endpoint"
        },
        {
            "location": "/contributing/",
            "text": "Contributing\n\n\nYour help or feedback is highly appreciated! Please do so by creating an issue in the \nGithub repository\n.\n\n\nWhen contributing code, please make sure the tests pass:\n\n\ngit clone https://github.com/kukua/concava\ncd concava\nnpm install\nnpm test\n\n\n\n\nYou can also contact use via email at \ndev@kukua.cc\n.\n\n\nAdapters\n\n\nTo write your own adapter, use the function templates from the \nconfiguration page\n. The official adapters are published as \nmodules on NPM\n. The module name should be prefixed with \nconcava-adapter-\n.\n\n\nYou can use the \nMySQL adapter code\n as a starting point to write your own.\n\n\nConnectors\n\n\nFollow these steps to create a connector for the protocol you wish to use:\n\n\n\n\nMake sure the connector \nisn't already available\n.\n\n\nCreate a listener service for your protocol\n\n\nWhen receiving new data collect the UDID, binary payload, and optionally the authorization header/token\n\n\nDo a HTTP request to ConCaVa. See the \nAPI documentation\n for details.\n\n\nPublish on Docker Hub. The image name should be prefixed with \nconcava-connector-\n.\n\n\n\n\nYou can use the \nLoRa for The Things Network connector code\n as a starting point to write your own.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#contributing",
            "text": "Your help or feedback is highly appreciated! Please do so by creating an issue in the  Github repository .  When contributing code, please make sure the tests pass:  git clone https://github.com/kukua/concava\ncd concava\nnpm install\nnpm test  You can also contact use via email at  dev@kukua.cc .",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#adapters",
            "text": "To write your own adapter, use the function templates from the  configuration page . The official adapters are published as  modules on NPM . The module name should be prefixed with  concava-adapter- .  You can use the  MySQL adapter code  as a starting point to write your own.",
            "title": "Adapters"
        },
        {
            "location": "/contributing/#connectors",
            "text": "Follow these steps to create a connector for the protocol you wish to use:   Make sure the connector  isn't already available .  Create a listener service for your protocol  When receiving new data collect the UDID, binary payload, and optionally the authorization header/token  Do a HTTP request to ConCaVa. See the  API documentation  for details.  Publish on Docker Hub. The image name should be prefixed with  concava-connector- .   You can use the  LoRa for The Things Network connector code  as a starting point to write your own.",
            "title": "Connectors"
        }
    ]
}