{
    "docs": [
        {
            "location": "/",
            "text": "ConCaVa\n\n\nConfiguration driven binary payload processor for Converting, Calibrating, and Validating dynamic sensor data.\n\n\n\nThis description is a mouthful, so let's break it down:\n\n\n\n\nConfiguration driven:\n instead of writing custom software to handle sensor data, ConCaVa allows you to configure how the data of each device should be processed.\n\n\nBinary payload processor:\n Sensing sensor data in binary is efficient and cheap, but requires a conversion step (how to make sense of all the ones and zeros).\n\n\nConverting data:\n Converting bits into numbers.\n\n\nCalibrating data:\n Custom functionality to alter the data.\n\n\nValidating data:\n Making sure the data is correct, e.g. lies within the range in which the sensor can measure.\n\n\nDynamic sensor data:\n Allowing different sensors to send their data to a single endpoint, no matter what the data format is.\n\n\n\n\nChallenges\n\n\nEfficiently processing sensor data of a big variety of devices is hard. But there is plenty of room of doing it in a generic way. That's where ConCaVa comes into play. These are the common challenges:\n\n\n\n\nLimited bandwidth.\n When sensors are sending over 3G or LoRa, bandwidth is limited. In these situations the amount of data must be brought to a minimum. Using formats like XML or JSON includes the data format, which costs extra bytes. Binary is the most efficient way of sending sensor data, however introduces other challenges like data conversion.\n\n\nConverting data.\n Sensors provide different types of data and often via different protocols (LoRa, MQTT, SigFox, etc.). This data needs to be converted. Usually done by software that is specifically developed for that use case.\n\n\nCalibrating data.\n Measurements require different types of calibration. E.g. sending a temperature as 16bit integer and dividing it by 100 to get a two decimal precision.\n\n\nValidating data.\n Each type of sensor is validated differently. E.g. checking if the measurement of a temperature sensor lies between its maximum bounds of -40\u00b0C and +85\u00b0C. If below or above, correct or discard the data. Each of these rules are implemented seperately.\n\n\nScalability.\n Adding new devices with different protocols requires changing the software that handles the incoming data.\n\n\n\n\nThe first point is solved by using binary data, points 2, 3, and 4 are solved by ConCaVa, and point 5 is solved by using a configuration driven approach.\n\n\nDataflow\n\n\nBefore going into detail, it is important to know how the data flows through a system that's using ConCaVa:\n\n\n\n\nSensors send their binary payload to the ConCaVa \nHTTP API endpoint\n. If a sensor communicates via a different protocol (LoRa, SPUL, MQTT, etc.) a \nconnector\n can be used to forward the data to ConCaVa, so the convert, calibrate, and validate steps can still be utilized. The image above shows usage of the \nSPUL protocol and connector\n.\n\n\nIn the next chapters the installation and configuration will be handled.\n\n\n\n\nFor contributing, providing feedback, or support please go to the \nGithub repository\n.\n\nSee the \nintroduction slides\n for a quick overview of ConCaVa.",
            "title": "Introduction"
        },
        {
            "location": "/#concava",
            "text": "Configuration driven binary payload processor for Converting, Calibrating, and Validating dynamic sensor data.  This description is a mouthful, so let's break it down:   Configuration driven:  instead of writing custom software to handle sensor data, ConCaVa allows you to configure how the data of each device should be processed.  Binary payload processor:  Sensing sensor data in binary is efficient and cheap, but requires a conversion step (how to make sense of all the ones and zeros).  Converting data:  Converting bits into numbers.  Calibrating data:  Custom functionality to alter the data.  Validating data:  Making sure the data is correct, e.g. lies within the range in which the sensor can measure.  Dynamic sensor data:  Allowing different sensors to send their data to a single endpoint, no matter what the data format is.",
            "title": "ConCaVa"
        },
        {
            "location": "/#challenges",
            "text": "Efficiently processing sensor data of a big variety of devices is hard. But there is plenty of room of doing it in a generic way. That's where ConCaVa comes into play. These are the common challenges:   Limited bandwidth.  When sensors are sending over 3G or LoRa, bandwidth is limited. In these situations the amount of data must be brought to a minimum. Using formats like XML or JSON includes the data format, which costs extra bytes. Binary is the most efficient way of sending sensor data, however introduces other challenges like data conversion.  Converting data.  Sensors provide different types of data and often via different protocols (LoRa, MQTT, SigFox, etc.). This data needs to be converted. Usually done by software that is specifically developed for that use case.  Calibrating data.  Measurements require different types of calibration. E.g. sending a temperature as 16bit integer and dividing it by 100 to get a two decimal precision.  Validating data.  Each type of sensor is validated differently. E.g. checking if the measurement of a temperature sensor lies between its maximum bounds of -40\u00b0C and +85\u00b0C. If below or above, correct or discard the data. Each of these rules are implemented seperately.  Scalability.  Adding new devices with different protocols requires changing the software that handles the incoming data.   The first point is solved by using binary data, points 2, 3, and 4 are solved by ConCaVa, and point 5 is solved by using a configuration driven approach.",
            "title": "Challenges"
        },
        {
            "location": "/#dataflow",
            "text": "Before going into detail, it is important to know how the data flows through a system that's using ConCaVa:   Sensors send their binary payload to the ConCaVa  HTTP API endpoint . If a sensor communicates via a different protocol (LoRa, SPUL, MQTT, etc.) a  connector  can be used to forward the data to ConCaVa, so the convert, calibrate, and validate steps can still be utilized. The image above shows usage of the  SPUL protocol and connector .  In the next chapters the installation and configuration will be handled.   For contributing, providing feedback, or support please go to the  Github repository . \nSee the  introduction slides  for a quick overview of ConCaVa.",
            "title": "Dataflow"
        },
        {
            "location": "/installation/",
            "text": "Installation\n\n\nConCaVa can be run as a NodeJS program or in a Docker container.\n\n\nNodeJS\n\n\ngit clone https://github.com/kukua/concava\ncd concava\ncp config.js.example config.js\nchmod 600 config.js\n# \n Edit config.js\n\nnpm install\nnpm start\n# Should show \nListening on port 3000\n in log file\n\n\n\n\nTested with NodeJS v5.0 and NPM v3.3.\n\n\nDocker\n\n\nFirst, \ninstall Docker\n. Then run:\n\n\ncurl https://raw.githubusercontent.com/kukua/concava/master/config.js.example \n config.js\nchmod 600 config.js\n# \n Edit config.js\n\ntouch /tmp/output.log\n\ndocker run -d -p 3000:3000 -v $PWD/config.js:/data/config.js \\\n    -v /tmp/output.log:/tmp/output.log --name concava kukuadev/concava\n# Should show \nListening on port 3000\n in log file\n\n\n\n\nTested with Docker v1.9.",
            "title": "Installation"
        },
        {
            "location": "/installation/#installation",
            "text": "ConCaVa can be run as a NodeJS program or in a Docker container.",
            "title": "Installation"
        },
        {
            "location": "/installation/#nodejs",
            "text": "git clone https://github.com/kukua/concava\ncd concava\ncp config.js.example config.js\nchmod 600 config.js\n#   Edit config.js\n\nnpm install\nnpm start\n# Should show  Listening on port 3000  in log file  Tested with NodeJS v5.0 and NPM v3.3.",
            "title": "NodeJS"
        },
        {
            "location": "/installation/#docker",
            "text": "First,  install Docker . Then run:  curl https://raw.githubusercontent.com/kukua/concava/master/config.js.example   config.js\nchmod 600 config.js\n#   Edit config.js\n\ntouch /tmp/output.log\n\ndocker run -d -p 3000:3000 -v $PWD/config.js:/data/config.js \\\n    -v /tmp/output.log:/tmp/output.log --name concava kukuadev/concava\n# Should show  Listening on port 3000  in log file  Tested with Docker v1.9.",
            "title": "Docker"
        },
        {
            "location": "/configuration/",
            "text": "Configuration\n\n\nThe ConCaVa repository contains a \nconfig.js.example file\n, containing all the configuration options.\n\n\nAdapters\n\n\nConCaVa allows you to provide your own authentication, metadata (device configuration), and storage. These are down through generic adapters.\nAdapters are simply asynchronous JavaScript functions. Each of these adapter functions accepts four or five arguments:\n\n\n// req = Express request\n// config = auth, metadata, or storage object from config.js\n// data = SensorData instance\n// classes = { SensorData, SensorAttribute }\n// cb = callback function\n\nfunction (req, config, data, cb) {}\nfunction (req, config, data, classes, cb) {}\n\n\n\n\nThe latter is used for providing metadata with the classes used by ConCaVa. If ConCaVa sees the function expects four arguments, it will ignore the \nclasses\n variable.\n\n\nAuthentication\n\n\nExample authentication adapter:\n\n\nfunction auth (req, config, data, cb) {\n    // return cb() // To disable authentication\n\n    console.log(req.auth) // { udid: '...', token: '...' }\n    // token will only be added if config.byToken === true\n\n    var user = { id: 1, name: 'User 1' }\n    cb(null, user)\n    // The value of user is assigned to req.user\n}\n\n\n\n\nMetadata\n\n\nExample metadata adapter:\n\n\nfunction metadata (req, config, data, classes, cb) {\n    // data is instance of classes.SensorData\n    if (data.getDeviceId() !== '0000000000000001') {\n        return cb('No metadata for device.')\n    }\n\n    var attr1 = new classes.SensorAttribute('attr1')\n    attr1.addConverter('uint32be')\n    attr1.addValidator('min', 100)\n    attr1.addValidator('max', 1300)\n\n    var attr2 = new classes.SensorAttribute('attr2')\n    attr2.addConverter('int16le')\n    attr2.addCalibrator('return val + 7')\n\n    data.setAttributes([attr1, attr2])\n    cb()\n}\n\n\n\n\nStorage\n\n\nThe data object can be retrieved with \ndata.getData()\n. This is a key/value object which uses the converter names (e.g. \nattr1\n and \nattr2\n) and their determined values. The following values are added by default:\n\n\ntimestamp      UNIX timestamp\n_raw           Hex string with raw payload\n\n\n\n\nThe approach here is to make the data time bound. Therefore a \ntimestamp\n is added. Which can be overriden by providing your own timestamp attribute in the payload, to use the time of the measurement instead of the time the payload has been received.\n\n\nExample storage adapter:\n\n\nfunction storage (req, config, data, cb) {\n    var udid = data.getDeviceId()\n\n    console.log(udid, data.getData())\n    cb()\n}\n\n\n\n\n\n    \nNote\n\n    \nIn debug mode, ConCaVa will also write the data to the log file.\n\n\n\n\n\nAvailable\n\n\nThe following adapters are available:\n\n\n\n\nMySQL authentication, metadata, and storage\n\n\nOrion Context Broker authentication, metadata, and storage\n\n\nMQTT storage\n\n\nInfluxDB storage\n\n\n\n\nSearch for 'adapter' on Github\n to see all official adapters.\nContributing other adapters is highly appreciated. See \nthe contributing page\n for more information.\n\n\nConnectors\n\n\nConnectors are used to support other communication protocols. They act as a proxy for ConCaVa. A connector extracts the UDID and binary payload from protocol packet of your liking. For example: the MQTT connector provides an MQTT broker that uses the \nclientId\n and \npassword\n configuration options for UDID and auth token. Any data it receives will used as binary payload to forward to ConCaVa.\n\n\nAvailable\n\n\nThe following connectors are available:\n\n\n\n\nLoRa\n. Handles LoRa XML (from a KPN server webhook for example).\n\n\nLoRa TTN\n. Handles The Things Network LoRa packets.\n\n\nMQTT\n.\n\n\nSPUL\n stands for \nSensor Protocol Ultra Light\n. Documentation can be \nfound here\n.\n\n\n\n\nSearch for 'ConCaVa' on the Docker Hub\n to see all connectors.\nContributing other connectors is highly appreciated. See \nthe contributing page\n for more information.\n\n\nOther Tooling\n\n\nWe've developed a standardized API and GUI for managing the MySQL metadata:\n\n\n\n\nhttps://github.com/kukua/concava-api\n\n\nhttps://github.com/kukua/concava-gui",
            "title": "Configuration"
        },
        {
            "location": "/configuration/#configuration",
            "text": "The ConCaVa repository contains a  config.js.example file , containing all the configuration options.",
            "title": "Configuration"
        },
        {
            "location": "/configuration/#adapters",
            "text": "ConCaVa allows you to provide your own authentication, metadata (device configuration), and storage. These are down through generic adapters.\nAdapters are simply asynchronous JavaScript functions. Each of these adapter functions accepts four or five arguments:  // req = Express request\n// config = auth, metadata, or storage object from config.js\n// data = SensorData instance\n// classes = { SensorData, SensorAttribute }\n// cb = callback function\n\nfunction (req, config, data, cb) {}\nfunction (req, config, data, classes, cb) {}  The latter is used for providing metadata with the classes used by ConCaVa. If ConCaVa sees the function expects four arguments, it will ignore the  classes  variable.  Authentication  Example authentication adapter:  function auth (req, config, data, cb) {\n    // return cb() // To disable authentication\n\n    console.log(req.auth) // { udid: '...', token: '...' }\n    // token will only be added if config.byToken === true\n\n    var user = { id: 1, name: 'User 1' }\n    cb(null, user)\n    // The value of user is assigned to req.user\n}  Metadata  Example metadata adapter:  function metadata (req, config, data, classes, cb) {\n    // data is instance of classes.SensorData\n    if (data.getDeviceId() !== '0000000000000001') {\n        return cb('No metadata for device.')\n    }\n\n    var attr1 = new classes.SensorAttribute('attr1')\n    attr1.addConverter('uint32be')\n    attr1.addValidator('min', 100)\n    attr1.addValidator('max', 1300)\n\n    var attr2 = new classes.SensorAttribute('attr2')\n    attr2.addConverter('int16le')\n    attr2.addCalibrator('return val + 7')\n\n    data.setAttributes([attr1, attr2])\n    cb()\n}  Storage  The data object can be retrieved with  data.getData() . This is a key/value object which uses the converter names (e.g.  attr1  and  attr2 ) and their determined values. The following values are added by default:  timestamp      UNIX timestamp\n_raw           Hex string with raw payload  The approach here is to make the data time bound. Therefore a  timestamp  is added. Which can be overriden by providing your own timestamp attribute in the payload, to use the time of the measurement instead of the time the payload has been received.  Example storage adapter:  function storage (req, config, data, cb) {\n    var udid = data.getDeviceId()\n\n    console.log(udid, data.getData())\n    cb()\n}  \n     Note \n     In debug mode, ConCaVa will also write the data to the log file.   Available  The following adapters are available:   MySQL authentication, metadata, and storage  Orion Context Broker authentication, metadata, and storage  MQTT storage  InfluxDB storage   Search for 'adapter' on Github  to see all official adapters.\nContributing other adapters is highly appreciated. See  the contributing page  for more information.",
            "title": "Adapters"
        },
        {
            "location": "/configuration/#connectors",
            "text": "Connectors are used to support other communication protocols. They act as a proxy for ConCaVa. A connector extracts the UDID and binary payload from protocol packet of your liking. For example: the MQTT connector provides an MQTT broker that uses the  clientId  and  password  configuration options for UDID and auth token. Any data it receives will used as binary payload to forward to ConCaVa.  Available  The following connectors are available:   LoRa . Handles LoRa XML (from a KPN server webhook for example).  LoRa TTN . Handles The Things Network LoRa packets.  MQTT .  SPUL  stands for  Sensor Protocol Ultra Light . Documentation can be  found here .   Search for 'ConCaVa' on the Docker Hub  to see all connectors.\nContributing other connectors is highly appreciated. See  the contributing page  for more information.  Other Tooling  We've developed a standardized API and GUI for managing the MySQL metadata:   https://github.com/kukua/concava-api  https://github.com/kukua/concava-gui",
            "title": "Connectors"
        },
        {
            "location": "/quick-start/",
            "text": "Quick Start\n\n\nBy following these steps you will setup ConCaVa using the built in JSON adapter.\nThis means the authentication, metadata, and storage will be loaded from JSON files. This tutorial assumes you know how to use Bash on a Unix or Linux environment.\n\n\nSetup\n\n\nInstall Docker\n and \nDocker Compose\n. Then run the following commands:\n\n\nmkdir my-concava\ncd my-concava\n\ncurl https://raw.githubusercontent.com/kukua/concava/master/config.js.example \n config.js\nchmod 600 config.js\n\ntouch output.log docker-compose.yml\nmkdir data\ntouch data/tokens.json data/metadata.json\n\n\n\n\nCopy the following text into the \ndocker-compose.yml\n file:\n\n\nconcava:\n    image: kukuadev/concava\n    ports:\n        - \n3000:3000\n\n    volumes:\n        - ./config.js:/data/config.js:ro\n        - ./output.log:/tmp/output.log\n        - ./data/:/data/data\n\n\n\n\nWith this configuration file we can easily create the container:\n\n\ndocker-compose up -d\n\n\n\n\nThat's it! We now have ConCaVa running on port 3000.\n\n\nSend data\n\n\nNext, we'll send device data to ConCaVa. For this we need the following:\n\n\nUDID           The unique device ID (16 lowercase hex characters),\n               for example: 0000000000000001\nAuth header    The authentication header,\n               for example: Token abcdef0123456789abcdef0123456789\nPayload        The measured data, normally in binary,\n               but for this example as a hex string\n\n\n\n\nWe'll use the following sensor specification:\n\n\n\n    \n\n        \n\n            \nMeasurement\n\n            \nValue\n\n            \nActual data\n\n            \nConverter\n\n            \nCalibrator\n\n            \nValidators\n\n        \n\n    \n\n    \n\n        \n\n            \nTemperature\n\n            \n23.4 \u00b0C\n\n            \n234\n\n            \nint16le\n\n            \nreturn val / 10\n\n            \nmin=-40 max=85\n\n        \n\n        \n\n            \nPressure\n\n            \n1017.9 hPa\n\n            \n10179\n\n            \nuint16le\n\n            \nreturn val / 10\n\n            \nmin=300 max=1100\n\n        \n\n        \n\n            \nHumidity\n\n            \n38.7 %\n\n            \n387\n\n            \nuint16le\n\n            \nreturn val / 10\n\n            \nmin=0 max=100\n\n        \n\n        \n\n            \nLatitude\n\n            \n52.0842715\n\n            \n52.0842715\n\n            \nfloatle\n\n            \n\n            \n\n        \n\n        \n\n            \nLongitude\n\n            \n5.0124524\n\n            \n5.0124524\n\n            \nfloatle\n\n            \n\n            \n\n        \n\n    \n\n\n\n\n\nFor temperature, pressure, and humidity using floats is inefficient (\n3 x 4 bytes = 12 bytes\n). Instead we fix the value to one decimal number and multiply it by 10 and later divide it by 10 again. This allows us to use 16 bit integers (2 bytes per value) or \n3 x 2 = 6 bytes\n in total. This cuts our number of bytes in half!\n\n\nIn this tutorial we also send the device's GPS coordinates.a latitude and longitude.\n\n\nIt is common to use the \nLittle Endian\n byte order when sending data from devices. This means the little end (byte with smallest part of value) comes first.\n\n\nTranslating these values to a hexadecimal payload looks like this:\n\n\nTemperature    0xea00\nPressure       0xc327\nHumidity       0x8301\nLatitude       0x4b565042\nLongitude      0x0366a040\n\nFinal payload  0xea00c32783014b5650420366a040\n\n\n\n\nSend this to ConCaVa by running:\n\n\necho 'ea00c32783014b5650420366a040' | xxd -r -p | \\\n    curl -i -XPUT 'http://localhost:3000/v1/sensorData/0000000000000001' \\\n    -H 'Authorization: Token abcdef0123456789abcdef0123456789' \\\n    -H 'Content-Type: application/octet-stream' --data-binary @-\n\n\n\n\nThe response will look like this:\n\n\nHTTP/1.1 401 Unauthorized\nAllow: HEAD, POST, PUT\nAccept: application/octet-stream\nWWW-Authenticate: Token\nDate: Mon, 11 Jul 2016 13:30:16 GMT\nConnection: keep-alive\nTransfer-Encoding: chunked\n\nUnauthorized token.\n\n\n\n\nSuccess! Sort of. We need to configure ConCaVa to be able to handle the request.\n\n\nAdd tokens\n\n\nNow we add our token to \ndata/tokens.json\n:\n\n\n{\n    \nabcdef0123456789abcdef0123456789\n: {\n        \nid\n: 1,\n        \nname\n: \nUser 1\n\n    }\n}\n\n\n\n\nHere you see the unique authentication token as the key and the user data object as the value. Run the \ncurl\n request again, the response will look like this:\n\n\nHTTP/1.1 400 Bad Request\nAllow: HEAD, POST, PUT\nAccept: application/octet-stream\nDate: Mon, 11 Jul 2016 13:34:40 GMT\nConnection: keep-alive\nTransfer-Encoding: chunked\n\nNo metadata for 0000000000000001.\n\n\n\n\nAgain, success! But no data yet. We need to add the metadata for this specific device.\n\n\nAdd metadata\n\n\nAdd this metadata to \ndata/metadata.json\n:\n\n\n{\n    \n0000000000000001\n: [\n        {\n            \nname\n: \ntemperature\n,\n            \nconverters\n: [\nint16le\n],\n            \ncalibrators\n: [\nreturn val / 10\n],\n            \nvalidators\n: [\n                [\nmin\n, -40],\n                [\nmax\n, 85]\n            ]\n        },\n        {\n            \nname\n: \npressure\n,\n            \nconverters\n: [\nuint16le\n],\n            \ncalibrators\n: [\nreturn val / 10\n],\n            \nvalidators\n: [\n                [\nmin\n, 300],\n                [\nmax\n, 1100]\n            ]\n        },\n        {\n            \nname\n: \nhumidity\n,\n            \nconverters\n: [\nuint16le\n],\n            \ncalibrators\n: [\nreturn val / 10\n],\n            \nvalidators\n: [\n                [\nmin\n, 0],\n                [\nmax\n, 100]\n            ]\n        },\n        {\n            \nname\n: \nlat\n,\n            \nconverters\n: [\nfloatle\n],\n            \ncalibrators\n: [],\n            \nvalidators\n: []\n        },\n        {\n            \nname\n: \nlng\n,\n            \nconverters\n: [\nfloatle\n],\n            \ncalibrators\n: [],\n            \nvalidators\n: []\n        }\n    ]\n}\n\n\n\n\nThis is the JSON adapter format for the metadata in the table you saw earlier. Compare them to see that we used the exact same configuration.\n\n\nThird time's the charm: run the \ncurl\n request again. The response should be:\n\n\nHTTP/1.1 200 OK\nAllow: HEAD, POST, PUT\nAccept: application/octet-stream\nDate: Mon, 11 Jul 2016 13:49:03 GMT\nConnection: keep-alive\nContent-Length: 0\n\n\n\n\nSuccess! But how do we view the data?\n\n\nStored measurements\n\n\nOpen \ndata/store.0000000000000001.json\n to show the data, which looks like this:\n\n\n{\n  \nb6a84c4e-8014-4681-b78b-89a7c1c97a86\n: {\n    \n_raw\n: \nea00c32783014b5650420366a040\n,\n    \ntemperature\n: 23.4,\n    \npressure\n: 1017.9,\n    \nhumidity\n: 38.7,\n    \nlat\n: 52.08427047729492,\n    \nlng\n: 5.012452602386475,\n    \ntimestamp\n: 1468244943\n  }\n}\n\n\n\n\n\n    \nTip\n\n    \nUse \njq\n for displaying JSON data.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#quick-start",
            "text": "By following these steps you will setup ConCaVa using the built in JSON adapter.\nThis means the authentication, metadata, and storage will be loaded from JSON files. This tutorial assumes you know how to use Bash on a Unix or Linux environment.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#setup",
            "text": "Install Docker  and  Docker Compose . Then run the following commands:  mkdir my-concava\ncd my-concava\n\ncurl https://raw.githubusercontent.com/kukua/concava/master/config.js.example   config.js\nchmod 600 config.js\n\ntouch output.log docker-compose.yml\nmkdir data\ntouch data/tokens.json data/metadata.json  Copy the following text into the  docker-compose.yml  file:  concava:\n    image: kukuadev/concava\n    ports:\n        -  3000:3000 \n    volumes:\n        - ./config.js:/data/config.js:ro\n        - ./output.log:/tmp/output.log\n        - ./data/:/data/data  With this configuration file we can easily create the container:  docker-compose up -d  That's it! We now have ConCaVa running on port 3000.",
            "title": "Setup"
        },
        {
            "location": "/quick-start/#send-data",
            "text": "Next, we'll send device data to ConCaVa. For this we need the following:  UDID           The unique device ID (16 lowercase hex characters),\n               for example: 0000000000000001\nAuth header    The authentication header,\n               for example: Token abcdef0123456789abcdef0123456789\nPayload        The measured data, normally in binary,\n               but for this example as a hex string  We'll use the following sensor specification:  \n     \n         \n             Measurement \n             Value \n             Actual data \n             Converter \n             Calibrator \n             Validators \n         \n     \n     \n         \n             Temperature \n             23.4 \u00b0C \n             234 \n             int16le \n             return val / 10 \n             min=-40 max=85 \n         \n         \n             Pressure \n             1017.9 hPa \n             10179 \n             uint16le \n             return val / 10 \n             min=300 max=1100 \n         \n         \n             Humidity \n             38.7 % \n             387 \n             uint16le \n             return val / 10 \n             min=0 max=100 \n         \n         \n             Latitude \n             52.0842715 \n             52.0842715 \n             floatle \n             \n             \n         \n         \n             Longitude \n             5.0124524 \n             5.0124524 \n             floatle \n             \n             \n         \n       For temperature, pressure, and humidity using floats is inefficient ( 3 x 4 bytes = 12 bytes ). Instead we fix the value to one decimal number and multiply it by 10 and later divide it by 10 again. This allows us to use 16 bit integers (2 bytes per value) or  3 x 2 = 6 bytes  in total. This cuts our number of bytes in half!  In this tutorial we also send the device's GPS coordinates.a latitude and longitude.  It is common to use the  Little Endian  byte order when sending data from devices. This means the little end (byte with smallest part of value) comes first.  Translating these values to a hexadecimal payload looks like this:  Temperature    0xea00\nPressure       0xc327\nHumidity       0x8301\nLatitude       0x4b565042\nLongitude      0x0366a040\n\nFinal payload  0xea00c32783014b5650420366a040  Send this to ConCaVa by running:  echo 'ea00c32783014b5650420366a040' | xxd -r -p | \\\n    curl -i -XPUT 'http://localhost:3000/v1/sensorData/0000000000000001' \\\n    -H 'Authorization: Token abcdef0123456789abcdef0123456789' \\\n    -H 'Content-Type: application/octet-stream' --data-binary @-  The response will look like this:  HTTP/1.1 401 Unauthorized\nAllow: HEAD, POST, PUT\nAccept: application/octet-stream\nWWW-Authenticate: Token\nDate: Mon, 11 Jul 2016 13:30:16 GMT\nConnection: keep-alive\nTransfer-Encoding: chunked\n\nUnauthorized token.  Success! Sort of. We need to configure ConCaVa to be able to handle the request.",
            "title": "Send data"
        },
        {
            "location": "/quick-start/#add-tokens",
            "text": "Now we add our token to  data/tokens.json :  {\n     abcdef0123456789abcdef0123456789 : {\n         id : 1,\n         name :  User 1 \n    }\n}  Here you see the unique authentication token as the key and the user data object as the value. Run the  curl  request again, the response will look like this:  HTTP/1.1 400 Bad Request\nAllow: HEAD, POST, PUT\nAccept: application/octet-stream\nDate: Mon, 11 Jul 2016 13:34:40 GMT\nConnection: keep-alive\nTransfer-Encoding: chunked\n\nNo metadata for 0000000000000001.  Again, success! But no data yet. We need to add the metadata for this specific device.",
            "title": "Add tokens"
        },
        {
            "location": "/quick-start/#add-metadata",
            "text": "Add this metadata to  data/metadata.json :  {\n     0000000000000001 : [\n        {\n             name :  temperature ,\n             converters : [ int16le ],\n             calibrators : [ return val / 10 ],\n             validators : [\n                [ min , -40],\n                [ max , 85]\n            ]\n        },\n        {\n             name :  pressure ,\n             converters : [ uint16le ],\n             calibrators : [ return val / 10 ],\n             validators : [\n                [ min , 300],\n                [ max , 1100]\n            ]\n        },\n        {\n             name :  humidity ,\n             converters : [ uint16le ],\n             calibrators : [ return val / 10 ],\n             validators : [\n                [ min , 0],\n                [ max , 100]\n            ]\n        },\n        {\n             name :  lat ,\n             converters : [ floatle ],\n             calibrators : [],\n             validators : []\n        },\n        {\n             name :  lng ,\n             converters : [ floatle ],\n             calibrators : [],\n             validators : []\n        }\n    ]\n}  This is the JSON adapter format for the metadata in the table you saw earlier. Compare them to see that we used the exact same configuration.  Third time's the charm: run the  curl  request again. The response should be:  HTTP/1.1 200 OK\nAllow: HEAD, POST, PUT\nAccept: application/octet-stream\nDate: Mon, 11 Jul 2016 13:49:03 GMT\nConnection: keep-alive\nContent-Length: 0  Success! But how do we view the data?",
            "title": "Add metadata"
        },
        {
            "location": "/quick-start/#stored-measurements",
            "text": "Open  data/store.0000000000000001.json  to show the data, which looks like this:  {\n   b6a84c4e-8014-4681-b78b-89a7c1c97a86 : {\n     _raw :  ea00c32783014b5650420366a040 ,\n     temperature : 23.4,\n     pressure : 1017.9,\n     humidity : 38.7,\n     lat : 52.08427047729492,\n     lng : 5.012452602386475,\n     timestamp : 1468244943\n  }\n}  \n     Tip \n     Use  jq  for displaying JSON data.",
            "title": "Stored measurements"
        },
        {
            "location": "/api/",
            "text": "HTTP API endpoint\n\n\nConCaVa accepts the following HTTP requests:\n\n\n\n\nPOST /v1/sensorData\n\n\nPUT /v1/sensorData/\ndeviceID\n (where \ndeviceID\n is a lowercase 16 character hex string)\n\n\n\n\nThe requests are identical, except for the device ID which using a \nPOST\n request is prepended to the binary payload.\n\n\nThe following headers are required:\n\n\n\n\nContent-Type: application/octet-stream\n\n\nAuthorization: \nauth\n (e.g. \nToken abcdef0123456789abcdef0123456789\n)\n\n\n\n\nYou can use one of these commands for testing:\n\n\necho '\ndeviceID\nhex\n' | xxd -r -p | \\\n    curl -i -XPOST 'http://localhost:3000/v1/sensorData' \\\n    -H 'Authorization: Token \ntoken\n' \\\n    -H 'Content-Type: application/octet-stream' --data-binary @-\n\necho '\nhex\n' | xxd -r -p | \\\n    curl -i -XPUT 'http://localhost:3000/v1/sensorData/\ndeviceID\n' \\\n    -H 'Authorization: Token \ntoken\n' \\\n    -H 'Content-Type: application/octet-stream' --data-binary @-",
            "title": "API"
        },
        {
            "location": "/api/#http-api-endpoint",
            "text": "ConCaVa accepts the following HTTP requests:   POST /v1/sensorData  PUT /v1/sensorData/ deviceID  (where  deviceID  is a lowercase 16 character hex string)   The requests are identical, except for the device ID which using a  POST  request is prepended to the binary payload.  The following headers are required:   Content-Type: application/octet-stream  Authorization:  auth  (e.g.  Token abcdef0123456789abcdef0123456789 )   You can use one of these commands for testing:  echo ' deviceID hex ' | xxd -r -p | \\\n    curl -i -XPOST 'http://localhost:3000/v1/sensorData' \\\n    -H 'Authorization: Token  token ' \\\n    -H 'Content-Type: application/octet-stream' --data-binary @-\n\necho ' hex ' | xxd -r -p | \\\n    curl -i -XPUT 'http://localhost:3000/v1/sensorData/ deviceID ' \\\n    -H 'Authorization: Token  token ' \\\n    -H 'Content-Type: application/octet-stream' --data-binary @-",
            "title": "HTTP API endpoint"
        },
        {
            "location": "/contributing/",
            "text": "Contributing\n\n\nYour help or feedback is highly appreciated! Please do so by creating an issue in the \nGithub repository\n.\n\n\nWhen contributing code, please make sure the tests pass:\n\n\ngit clone https://github.com/kukua/concava\ncd concava\nnpm install\nnpm test\n\n\n\n\nYou can also contact use via email at \ndev@kukua.cc\n.\n\n\nAdapters\n\n\nTo write your own adapter, use the function templates from the \nconfiguration page\n. The official adapters are published as \nmodules on NPM\n. The module name should be prefixed with \nconcava-adapter-\n.\n\n\nYou can use the \nMySQL adapter code\n as a starting point to write your own.\n\n\nConnectors\n\n\nFollow these steps to create a connector for the protocol you wish to use:\n\n\n\n\nMake sure the connector \nisn't already available\n.\n\n\nCreate a listener service for your protocol\n\n\nWhen receiving new data collect the UDID, binary payload, and optionally the authorization header/token\n\n\nDo a HTTP request to ConCaVa. See the \nAPI documentation\n for details.\n\n\nPublish on Docker Hub. The image name should be prefixed with \nconcava-connector-\n.\n\n\n\n\nYou can use the \nLoRa for The Things Network connector code\n as a starting point to write your own.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#contributing",
            "text": "Your help or feedback is highly appreciated! Please do so by creating an issue in the  Github repository .  When contributing code, please make sure the tests pass:  git clone https://github.com/kukua/concava\ncd concava\nnpm install\nnpm test  You can also contact use via email at  dev@kukua.cc .",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#adapters",
            "text": "To write your own adapter, use the function templates from the  configuration page . The official adapters are published as  modules on NPM . The module name should be prefixed with  concava-adapter- .  You can use the  MySQL adapter code  as a starting point to write your own.",
            "title": "Adapters"
        },
        {
            "location": "/contributing/#connectors",
            "text": "Follow these steps to create a connector for the protocol you wish to use:   Make sure the connector  isn't already available .  Create a listener service for your protocol  When receiving new data collect the UDID, binary payload, and optionally the authorization header/token  Do a HTTP request to ConCaVa. See the  API documentation  for details.  Publish on Docker Hub. The image name should be prefixed with  concava-connector- .   You can use the  LoRa for The Things Network connector code  as a starting point to write your own.",
            "title": "Connectors"
        }
    ]
}